<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Student Expense Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Bootstrap 5 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">

  <!-- PouchDB -->
  <script src="https://cdn.jsdelivr.net/npm/pouchdb@7.3.1/dist/pouchdb.min.js"></script>
</head>
<body>
  <div class="container my-4">
    <h1 class="text-center mb-4">Welcome, {{ username }}!</h1>
    <div class="text-end mb-3">
      <a href="/logout" class="btn btn-outline-danger btn-sm">Logout</a>
    </div>

    <!-- Add Expense Form -->
    <h3>Add Expense</h3>
    <form id="offline-form" class="mb-4">
      <div class="mb-2">
        <label class="form-label">Date</label>
        <input type="date" name="date" class="form-control" required>
      </div>
      <div class="mb-2">
        <label class="form-label">Amount</label>
        <input type="number" step="0.01" name="amount" class="form-control" placeholder="Amount" required>
      </div>
      <div class="mb-2">
        <label class="form-label">Category</label>
        <input type="text" name="category" class="form-control" placeholder="Category" required>
      </div>
      <div class="mb-2">
        <label class="form-label">Description</label>
        <input type="text" name="description" class="form-control" placeholder="Description">
      </div>
      <button type="submit" class="btn btn-primary w-100">Add Expense</button>
    </form>

    <button id="voice-button" type="button" class="btn btn-outline-primary w-100 mt-2">
        üé§ Hold to Speak
      </button>
      
      

    <!-- Unsynced Local Expenses -->
    <h4>Unsynced Expenses (Local)</h4>
    <ul id="unsynced-list" class="list-group mb-2"></ul>
    <button id="sync-btn" onclick="syncExpenses()" class="btn btn-secondary btn-sm mb-3">Sync to Server</button>
    <p id="sync-status" class="text-muted"></p>

    <!-- Filters -->
    <h4>Filter by Month and Year</h4>
    <div class="row g-2 mb-3">
      <div class="col-md-6">
        <select id="filter-year" class="form-select">
          <option value="">All Years</option>
          <option value="2024">2024</option>
          <option value="2025">2025</option>
        </select>
      </div>
      <div class="col-md-6">
        <select id="filter-month" class="form-select">
          <option value="">All Months</option>
          <option value="01">January</option>
          <option value="02">February</option>
          <option value="03">March</option>
          <option value="04">April</option>
          <option value="05">May</option>
          <option value="06">June</option>
          <option value="07">July</option>
          <option value="08">August</option>
          <option value="09">September</option>
          <option value="10">October</option>
          <option value="11">November</option>
          <option value="12">December</option>
        </select>
      </div>
    </div>

    <div class="mb-3">
      <input type="text" id="filter-input" class="form-control" placeholder="Search by category or description">
    </div>

    <!-- Synced Expenses -->
    <h4 class="mt-4">Your Expenses</h4>
    <p id="total-expense" class="fw-bold">Total: $0.00</p>
    <button onclick="toggleManageMode()" class="btn btn-outline-secondary btn-sm mb-2">Manage Expenses ‚úèÔ∏è</button>
    <ul id="synced-expenses" class="list-group"></ul>
  </div>



  <!-- JavaScript Logic -->
  <script>
    const db = new PouchDB('local-expenses');
    const form = document.getElementById('offline-form');
    const unsyncedList = document.getElementById('unsynced-list');
    const syncStatus = document.getElementById('sync-status');
    const syncBtn = document.getElementById('sync-btn');
    let manageMode = false;

    function displayLocalExpenses() {
      unsyncedList.innerHTML = '';
      db.allDocs({ include_docs: true }).then(result => {
        result.rows.forEach(row => {
          const exp = row.doc;
          const li = document.createElement('li');
          li.textContent = `${exp.date} - $${exp.amount} - ${exp.category} - ${exp.description} üîÑ Not Synced`;
          unsyncedList.appendChild(li);
        });
      });
    }

    async function refreshSyncedExpenses() {
      const response = await fetch('/api/expenses');
      const data = await response.json();
      const list = document.getElementById('synced-expenses');
      list.innerHTML = '';

      if (data.length === 0) {
        list.innerHTML = '<li>No expenses yet.</li>';
        return;
      }

      data.forEach(exp => {
        const li = document.createElement('li');
        const [year, month] = exp.date.split('-');
        li.setAttribute('data-year', year);
        li.setAttribute('data-month', month);
        li.innerHTML = `
          ${exp.date} - $${exp.amount} - ${exp.category} - ${exp.description} ‚úÖ Synced
          <span class="action-buttons" style="display: none;">
            <button onclick="editExpense(${exp.id}, '${exp.date}', ${exp.amount}, '${exp.category}', '${exp.description}')">‚úèÔ∏è</button>
            <button onclick="deleteExpense(${exp.id})">üóëÔ∏è</button>
          </span>
        `;
        list.appendChild(li);
      });

      updateActionButtonsVisibility();
      applyCombinedFilters();
    }

    function updateActionButtonsVisibility() {
      const buttons = document.querySelectorAll('.action-buttons');
      buttons.forEach(span => {
        span.style.display = manageMode ? 'inline' : 'none';
      });
    }

    function toggleManageMode() {
      manageMode = !manageMode;
      updateActionButtonsVisibility();
    }

    const defaultSubmitHandler = async function (e) {
      e.preventDefault();
      const formData = new FormData(form);
      const expense = {
        _id: new Date().toISOString(),
        date: formData.get('date'),
        amount: parseFloat(formData.get('amount')),
        category: formData.get('category'),
        description: formData.get('description'),
        synced: false
      };

      if (navigator.onLine) {
        try {
          const res = await fetch('/sync', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify([expense])
          });

          if (res.ok) {
            await refreshSyncedExpenses();
            form.reset();
            syncStatus.textContent = "Expense synced directly!";
            return;
          }
        } catch (err) {
          console.warn("[WARN] Sync failed, storing locally.");
        }
      }

      await db.put(expense);
      form.reset();
      displayLocalExpenses();
    };

    form.onsubmit = defaultSubmitHandler;

    async function syncExpenses() {
      const result = await db.allDocs({ include_docs: true });
      const unsynced = result.rows.map(row => row.doc);

      if (unsynced.length === 0) {
        syncStatus.textContent = "Nothing to sync.";
        return;
      }

      try {
        const res = await fetch('/sync', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(unsynced)
        });

        if (res.ok) {
          for (let exp of unsynced) {
            await db.remove(exp);
          }
          displayLocalExpenses();
          await refreshSyncedExpenses();
          syncStatus.textContent = "Synced successfully!";
        } else {
          syncStatus.textContent = "Server error while syncing.";
        }
      } catch (err) {
        syncStatus.textContent = "Sync failed. Try again later.";
      }
    }

    function editExpense(id, date, amount, category, description) {
      form.date.value = date;
      form.amount.value = amount;
      form.category.value = category;
      form.description.value = description;

      form.onsubmit = async function (e) {
        e.preventDefault();
        const updated = {
          date: form.date.value,
          amount: parseFloat(form.amount.value),
          category: form.category.value,
          description: form.description.value
        };

        const res = await fetch(`/edit-expense/${id}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(updated)
        });

        if (res.ok) {
          await refreshSyncedExpenses();
          form.reset();
          form.onsubmit = defaultSubmitHandler;
        }
      };
    }

    async function deleteExpense(id) {
      if (!confirm('Delete this expense?')) return;
      const res = await fetch(`/delete-expense/${id}`, { method: 'DELETE' });
      if (res.ok) {
        await refreshSyncedExpenses();
      }
    }

    function toggleSyncButton() {
      syncBtn.style.display = navigator.onLine ? 'none' : 'inline-block';
    }

    function applyCombinedFilters() {
        const keyword = document.getElementById('filter-input').value.toLowerCase();
        const selectedYear = document.getElementById('filter-year').value;
        const selectedMonth = document.getElementById('filter-month').value;
        const list = document.getElementById('synced-expenses');
        const items = list.children;

        let total = 0;

        Array.from(items).forEach(li => {
            const text = li.textContent.toLowerCase();
            const itemYear = li.getAttribute('data-year');
            const itemMonth = li.getAttribute('data-month');

            const matchesText = text.includes(keyword);
            const matchesYear = selectedYear === '' || selectedYear === itemYear;
            const matchesMonth = selectedMonth === '' || selectedMonth === itemMonth;

            const visible = matchesText && matchesYear && matchesMonth;
            li.style.display = visible ? '' : 'none';

            if (visible) {
            // Try to extract the amount from the li text (assumes format: "$amount")
            const match = li.textContent.match(/\$(\d+(\.\d{1,2})?)/);
            if (match) {
                total += parseFloat(match[1]);
            }
            }
        });

        document.getElementById('total-expense').textContent = `Total: $${total.toFixed(2)}`;
        }


    // Filter event listeners
    document.getElementById('filter-input').addEventListener('input', applyCombinedFilters);
    document.getElementById('filter-year').addEventListener('change', applyCombinedFilters);
    document.getElementById('filter-month').addEventListener('change', applyCombinedFilters);

    // Auto-sync
    window.addEventListener('online', async () => {
      console.log('[INFO] Online: syncing...');
      await syncExpenses();
      await refreshSyncedExpenses();
      toggleSyncButton();
    });

    window.addEventListener('offline', toggleSyncButton);
    window.addEventListener('load', () => {
      displayLocalExpenses();
      toggleSyncButton();
      refreshSyncedExpenses();
    });

    function startVoiceInput() {
    if (!('webkitSpeechRecognition' in window)) {
      alert("Sorry, your browser doesn't support speech recognition.");
      return;
    }

    const recognition = new webkitSpeechRecognition();
    recognition.lang = 'en-US';
    recognition.interimResults = false;
    recognition.maxAlternatives = 1;

    recognition.start();
    recognition.onresult = function(event) {
      const transcript = event.results[0][0].transcript.toLowerCase();
      console.log("Voice input:", transcript);

      // Example: "spent 3 dollars on food for lunch"
      const amountMatch = transcript.match(/\d+(\.\d+)?/);
      const categoryMatch = transcript.match(/on\s(\w+)/);
      const description = transcript;

      if (amountMatch) {
        document.querySelector('input[name="amount"]').value = amountMatch[0];
      }

      if (categoryMatch) {
        document.querySelector('input[name="category"]').value = categoryMatch[1];
      }

      document.querySelector('input[name="description"]').value = description;
    };

    recognition.onerror = function(event) {
      alert("Voice input failed: " + event.error);
    };
  }
  
  let recognition;
  let isRecognizing = false;

  const voiceBtn = document.getElementById('voice-button');

  if ('webkitSpeechRecognition' in window) {
    recognition = new webkitSpeechRecognition();
    recognition.lang = 'en-US';
    recognition.interimResults = true;  // ‚úÖ Enables faster parsing
    recognition.maxAlternatives = 1;

    recognition.onstart = () => {
      console.log("[INFO] Voice recognition started");
    };

    recognition.onresult = function(event) {
      let combinedTranscript = '';

      for (let i = event.resultIndex; i < event.results.length; i++) {
        const transcript = event.results[i][0].transcript;
        combinedTranscript += transcript + ' ';
      }

      combinedTranscript = combinedTranscript.trim().toLowerCase();
      console.log("[VOICE INPUT] Live transcript:", combinedTranscript);

      // Live-fill description
      document.querySelector('input[name="description"]').value = combinedTranscript;

      // Live-fill amount (any number)
      const amountMatch = combinedTranscript.match(/\d+(\.\d+)?/);
      if (amountMatch) {
        document.querySelector('input[name="amount"]').value = amountMatch[0];
      }

      // Live-fill category (after "on ...")
      const categoryMatch = combinedTranscript.match(/on\s+([a-z]+)/);
      if (categoryMatch) {
        document.querySelector('input[name="category"]').value = categoryMatch[1];
      }
    };

    recognition.onerror = function(event) {
      console.error("[ERROR] Voice recognition:", event.error);
    };

    recognition.onend = () => {
      console.log("[INFO] Voice recognition ended");
      isRecognizing = false;
      voiceBtn.textContent = 'üé§ Hold to Speak';
    };
  } else {
    alert("Your browser doesn't support voice input.");
  }

  // Push-to-talk bindings
  voiceBtn.addEventListener('mousedown', startListening);
  voiceBtn.addEventListener('touchstart', startListening);
  voiceBtn.addEventListener('mouseup', stopListening);
  voiceBtn.addEventListener('mouseleave', stopListening);
  voiceBtn.addEventListener('touchend', stopListening);

  function startListening(e) {
    e.preventDefault();
    if (recognition && !isRecognizing) {
      recognition.start();
      isRecognizing = true;
      voiceBtn.textContent = 'üéôÔ∏è Listening...';
    }
  }

  function stopListening(e) {
    e.preventDefault();
    if (recognition && isRecognizing) {
      recognition.stop();
      isRecognizing = false;
      voiceBtn.textContent = 'üé§ Hold to Speak';
      console.log("[DEBUG] Manual stop triggered");
    }
  }
</script>

  

  
  </script>
</body>
</html>
